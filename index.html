<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>clojure.core.memoize - core.memoize 1.0.258-SNAPSHOT API documentation</title>
    <link rel="icon" href="static/favicon.png" />
    <link rel="shortcut icon" href="static/favicon.png" />
    <link rel="stylesheet" href="static/clojure.css" type="text/css" media="all" />
    <link rel="stylesheet" href="static/wiki.css" type="text/css" media="all" />
    <link rel="stylesheet" href="static/internal.css" type="text/css" media="all" />
    <style>.menuWrapper{height: 36px;}</style>
  </head>
<!--
This document was auto-generated from the source by the clojure autodoc system.
To report errors or ask questions about the overall documentation structure, formatting,
etc., contact Tom Faulhaber (google mail name: tomfaulhaber).
For errors in the documentation of a particular namespace, contact the author of that
namespace.
-->
  <body>
    <div id="AllContentContainer">
      <div id="Header">
	<a href="index.html" id="Logo"><img src="static/clojure-icon.gif" width="100" height="100" alt="Clojure" /></a>
	<h1><a href="index.html" id="page-header" title="page header title">core.memoize API Reference</a></h1>
      </div>
      <div id="leftcolumn"><div style="text-align: center;"></div>
<div class="menu">
  <div class="WikiCustomNav WikiElement wiki">
    <span class="toc-header"><span id="project-name">core.memoize</span> <span id="version">1.0.258-SNAPSHOT</span> API</span><br />
    <ul>
      <li><a href="index.html" class="wiki_link">Overview</a></li>
      <li><a href="api-index.html" class="wiki_link">API Index</a></li>
    </ul>
    
    
    <a class="wiki_link" href="https://clojure.org">Clojure Home</a>
  </div>
</div>
</div>
      <div id="rightcolumn">
	<div id="Content">
	  <div class="contentBox"><div class="innerContentBox">
              <div class="wiki wikiPage" id="content_view">
                <div id="right-sidebar"><div id="toc">
  <h1 class="nopad">Table of Contents</h1>
  <div class="toc-section" style="margin-left: 1em;">
    <a style="margin-top: 3px;" href="#toc0">Overview</a>
    
  </div><div class="toc-section" style="margin-left: 1em;">
    <a style="margin-top: 3px;" href="#"></a>
    
  </div><div class="toc-section" style="margin-left: 1em;">
    <a style="margin-top: 3px;" href="#type-section">Types</a>
    <div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.memoize/PluggableMemoization" class="toc-entry-anchor">PluggableMemoization</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.memoize/RetryingDelay" class="toc-entry-anchor">RetryingDelay</a>
      
    </div>
  </div><div class="toc-section" style="margin-left: 1em;">
    <a style="margin-top: 3px;" href="#var-section">Vars and Functions</a>
    <div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.memoize/-&gt;PluggableMemoization" class="toc-entry-anchor">-&gt;PluggableMemoization</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.memoize/-&gt;RetryingDelay" class="toc-entry-anchor">-&gt;RetryingDelay</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.memoize/build-memoizer" class="toc-entry-anchor">build-memoizer</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.memoize/fifo" class="toc-entry-anchor">fifo</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.memoize/lazy-snapshot" class="toc-entry-anchor">lazy-snapshot</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.memoize/lru" class="toc-entry-anchor">lru</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.memoize/lu" class="toc-entry-anchor">lu</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.memoize/memo" class="toc-entry-anchor">memo</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.memoize/memo-clear!" class="toc-entry-anchor">memo-clear!</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.memoize/memo-fifo" class="toc-entry-anchor">memo-fifo</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.memoize/memo-lru" class="toc-entry-anchor">memo-lru</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.memoize/memo-lu" class="toc-entry-anchor">memo-lu</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.memoize/memo-reset!" class="toc-entry-anchor">memo-reset!</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.memoize/memo-swap!" class="toc-entry-anchor">memo-swap!</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.memoize/memo-ttl" class="toc-entry-anchor">memo-ttl</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.memoize/memoized?" class="toc-entry-anchor">memoized?</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.memoize/memoizer" class="toc-entry-anchor">memoizer</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.memoize/snapshot" class="toc-entry-anchor">snapshot</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.memoize/ttl" class="toc-entry-anchor">ttl</a>
      
    </div>
  </div><div class="toc-section" style="margin-left: 1em;">
    <a style="margin-top: 3px;" href="#"></a>
    
  </div>
</div>
</div>
                <div id="content-tag"><h1 id="overview">API for <span id="clojure.core.memoize">clojure.core.memoize</span>
  - <span id="header-project">core.memoize</span> <span id="header-version">1.0.258-SNAPSHOT</span><span id="header-status-block"> (<span id="header-status">in development</span>)</span>
  </h1>
<span id="author-line">by <span id="author-name">fogus</span><br /></span>
<br />Full namespace name: <span id="long-name">clojure.core.memoize</span>
<p></p>
<h2>Overview</h2>
<div id="home-page">Project home page is <a href="https://github.com/clojure/core.memoize/">https://github.com/clojure/core.memoize/</a></div>
<pre id="namespace-docstr">core.memoize is a memoization library offering functionality above
Clojure's core `memoize` function in the following ways:

**Pluggable memoization**

core.memoize allows for different back-end cache implmentations to
be used as appropriate without changing the memoization modus operandi.
See the `memoizer` function.

**Manipulable memoization**

Because core.memoize allows you to access a function's memoization store,
you do interesting things like clear it, modify it, and save it for later.
</pre>


<br />


<div id="type-section">
  <p></p>
  <h2>Types</h2>
  <div id="type-entry">
    <br />
    <hr />
    <h2 id="clojure.core.memoize/PluggableMemoization">PluggableMemoization</h2>
    <span id="type-type">type</span><br />
    <pre id="type-docstr"></pre>
    Fields: <span id="type-fields">[f cache]</span><br />
    Protocols: <span id="type-protocols">clojure.core.cache/CacheProtocol</span><br />
    Interfaces: <span id="type-interfaces"></span><br />
  </div><div id="type-entry">
    <br />
    <hr />
    <h2 id="clojure.core.memoize/RetryingDelay">RetryingDelay</h2>
    <span id="type-type">type</span><br />
    <pre id="type-docstr"></pre>
    Fields: <span id="type-fields">[fun available? value]</span><br />
    Protocols: <span id="type-protocols"></span><br />
    Interfaces: <span id="type-interfaces">clojure.lang.IDeref, clojure.lang.IPending</span><br />
  </div>
</div>
<div id="var-section">
  <p></p>
  <h2>Public Variables and Functions</h2>
  <div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.memoize/-&gt;PluggableMemoization">-&gt;PluggableMemoization</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (-&gt;PluggableMemoization f cache)
</pre>
    <pre id="var-docstr">Positional factory function for class clojure.core.memoize.PluggableMemoization.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.memoize/blob/2088ed2b2110a7b8deed03f3554f788ad3daae9e/src/main/clojure/clojure/core/memoize.clj#L78">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.memoize/-&gt;RetryingDelay">-&gt;RetryingDelay</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (-&gt;RetryingDelay fun available? value)
</pre>
    <pre id="var-docstr">Positional factory function for class clojure.core.memoize.RetryingDelay.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.memoize/blob/2088ed2b2110a7b8deed03f3554f788ad3daae9e/src/main/clojure/clojure/core/memoize.clj#L35">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.memoize/build-memoizer">build-memoizer</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (build-memoizer cache-factory f &amp; args)
</pre>
    <pre id="var-docstr">Builds a function that, given a function, returns a pluggable memoized
 version of it.  `build-memoizer` takes a cache factory function, and the
 arguments to that factory function -- at least one of those arguments
 should be the function to be memoized (it's usually the first argument).

`memoizer` above is a simpler version of `build-memoizer` that 'does the
right thing' with a cache and a seed hash map. `build-memoizer` remains
for backward compatibility but should be considered deprecated.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.memoize/blob/2088ed2b2110a7b8deed03f3554f788ad3daae9e/src/main/clojure/clojure/core/memoize.clj#L264">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.memoize/fifo">fifo</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (fifo f)
       (fifo f base)
       (fifo f tkey threshold)
       (fifo f base key threshold)
</pre>
    <pre id="var-docstr">Works the same as the basic memoization function (i.e. `memo`
and `core.memoize` except when a given threshold is breached.

Observe the following:

    (require '[clojure.core.memoize :as memo])

    (def id (memo/fifo identity :fifo/threshold 2))

    (id 42)
    (id 43)
    (snapshot id)
    ;=&gt; {[42] 42, [43] 43}

As you see, the limit of `2` has not been breached yet, but
if you call again with another value, then it is:

    (id 44)
    (snapshot id)
    ;=&gt; {[44] 44, [43] 43}

That is, the oldest entry `42` is pushed out of the
memoization cache.  This is the standard **F**irst **I**n
**F**irst **O**ut behavior.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.memoize/blob/2088ed2b2110a7b8deed03f3554f788ad3daae9e/src/main/clojure/clojure/core/memoize.clj#L357">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.memoize/lazy-snapshot">lazy-snapshot</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (lazy-snapshot memoized-fn)
</pre>
    <pre id="var-docstr">Returns a lazy snapshot of a core.memo-placed memoization cache.  By
lazy snapshot you can infer that what you get is only the cache contents at a
moment in time -- and, being lazy, the cache could change while you are
realizing the snapshot elements.

Returns a sequence of key/value pairs.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.memoize/blob/2088ed2b2110a7b8deed03f3554f788ad3daae9e/src/main/clojure/clojure/core/memoize.clj#L131">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.memoize/lru">lru</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (lru f)
       (lru f base)
       (lru f tkey threshold)
       (lru f base key threshold)
</pre>
    <pre id="var-docstr">Works the same as the basic memoization function (i.e. `memo`
and `core.memoize` except when a given threshold is breached.

Observe the following:

    (require '[clojure.core.memoize :as memo])

    (def id (memo/lru identity :lru/threshold 2))

    (id 42)
    (id 43)
    (snapshot id)
    ;=&gt; {[42] 42, [43] 43}

At this point the cache has not yet crossed the set threshold
of `2`, but if you execute yet another call the story will
change:

    (id 44)
    (snapshot id)
    ;=&gt; {[44] 44, [43] 43}

At this point the operation of the LRU cache looks exactly
the same at the FIFO cache.  However, the difference becomes
apparent on further use:

    (id 43)
    (id 0)
    (snapshot id)
    ;=&gt; {[0] 0, [43] 43}

As you see, once again calling `id` with the argument `43`
will expose the LRU nature of the underlying cache.  That is,
when the threshold is passed, the cache will expel the
**L**east **R**ecently **U**sed element in favor of the new.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.memoize/blob/2088ed2b2110a7b8deed03f3554f788ad3daae9e/src/main/clojure/clojure/core/memoize.clj#L398">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.memoize/lu">lu</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (lu f)
       (lu f base)
       (lu f tkey threshold)
       (lu f base key threshold)
</pre>
    <pre id="var-docstr">Similar to the implementation of memo-lru, except that this
function removes all cache values whose usage value is
smallest:

    (require '[clojure.core.memoize :as memo])

    (def id (memo/lu identity :lu/threshold 3))

    (id 42)
    (id 42)
    (id 43)
    (id 44)
    (snapshot id)
    ;=&gt; {[44] 44, [42] 42}

The **L**east **U**sed values are cleared on cache misses.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.memoize/blob/2088ed2b2110a7b8deed03f3554f788ad3daae9e/src/main/clojure/clojure/core/memoize.clj#L487">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.memoize/memo">memo</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (memo f)
       (memo f seed)
</pre>
    <pre id="var-docstr">Used as a more flexible alternative to Clojure's core `memoization`
function.  Memoized functions built using `memo` will respond to
the core.memo manipulable memoization utilities.  As a nice bonus,
you can use `memo` in place of `memoize` without any additional
changes, with the added guarantee that the memoized function will
only be called once for a given sequence of arguments (`memoize`
can call the function multiple times when concurrent calls are
made with the same sequence of arguments).

The default way to use this function is to simply supply a function
that will be memoized.  Additionally, you may also supply a map
of the form `'{[42] 42, [108] 108}` where keys are a vector
mapping expected argument values to arity positions.  The map values
are the return values of the memoized function.

If the supplied function has metadata containing an
`:clojure.core.memoize/args-fn` key, the value is assumed to be a
function that should be applied to the arguments to produce a
subset or transformed sequence of arguments that are used for the
key in the cache (the full, original arguments will still be used
to call the function). This allows you to memoize functions where
one or more arguments are irrelevant for memoization, such as the
`clojure.java.jdbc` functions, whose first argument may include
a (mutable) JDBC `Connection` object:

  (memo/memo (with-meta jdbc/execute! {::memo/args-fn rest}))

You can access the memoization cache directly via the `:clojure.core.memoize/cache` key
on the memoized function's metadata.  However, it is advised to
use the core.memo primitives instead as implementation details may
change over time.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.memoize/blob/2088ed2b2110a7b8deed03f3554f788ad3daae9e/src/main/clojure/clojure/core/memoize.clj#L278">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.memoize/memo-clear!">memo-clear!</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (memo-clear! f)
       (memo-clear! f args)
</pre>
    <pre id="var-docstr">Reaches into an core.memo-memoized function and clears the cache.  This is a
destructive operation and should be used with care.

When the second argument is a vector of input arguments, clears cache only
for argument vector.

Keep in mind that depending on what other threads or doing, an
immediate call to `snapshot` may not yield an empty cache.  That's
cool though, we've learned to deal with that stuff in Clojure by
now.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.memoize/blob/2088ed2b2110a7b8deed03f3554f788ad3daae9e/src/main/clojure/clojure/core/memoize.clj#L148">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.memoize/memo-fifo">memo-fifo</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (memo-fifo f)
       (memo-fifo f limit)
       (memo-fifo f limit base)
</pre>
    <pre id="var-docstr">DEPRECATED: Please use clojure.core.memoize/fifo instead.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.memoize/blob/2088ed2b2110a7b8deed03f3554f788ad3daae9e/src/main/clojure/clojure/core/memoize.clj#L350">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.memoize/memo-lru">memo-lru</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (memo-lru f)
       (memo-lru f limit)
       (memo-lru f limit base)
</pre>
    <pre id="var-docstr">DEPRECATED: Please use clojure.core.memoize/lru instead.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.memoize/blob/2088ed2b2110a7b8deed03f3554f788ad3daae9e/src/main/clojure/clojure/core/memoize.clj#L391">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.memoize/memo-lu">memo-lu</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (memo-lu f)
       (memo-lu f limit)
       (memo-lu f limit base)
</pre>
    <pre id="var-docstr">DEPRECATED: Please use clojure.core.memoize/lu instead.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.memoize/blob/2088ed2b2110a7b8deed03f3554f788ad3daae9e/src/main/clojure/clojure/core/memoize.clj#L480">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.memoize/memo-reset!">memo-reset!</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (memo-reset! f base)
</pre>
    <pre id="var-docstr">Takes a core.memo-populated function and a map and replaces the memoization cache
with the supplied map.  This is potentially some serious voodoo,
since you can effectively change the semantics of a function on the fly.

    (def id (memo identity))
    (memo-swap! id '{[13] :omg})
    (id 13)
    ;=&gt; :omg

With great power comes ... yadda yadda yadda.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.memoize/blob/2088ed2b2110a7b8deed03f3554f788ad3daae9e/src/main/clojure/clojure/core/memoize.clj#L166">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.memoize/memo-swap!">memo-swap!</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (memo-swap! f base)
       (memo-swap! f swap-fn args &amp; results)
</pre>
    <pre id="var-docstr">The 2-arity version takes a core.memo-populated function and a map and
replaces the memoization cache with the supplied map. Use `memo-reset!`
instead for replacing the cache as this 2-arity version of `memo-swap!`
should be considered deprecated.

The 3+-arity version takes a core.memo-populated function and arguments
similar to what you would pass to `clojure.core/swap!` and performs a
`swap!` on the underlying cache. In order to satisfy core.memoize's
world view, the assumption is that you will generally be calling it like:

      (def id (memo identity))
      (memo-swap! id clojure.core.cache/miss [13] :omg)
      (id 13)
      ;=&gt; :omg

You'll nearly always use `clojure.core.cache/miss` for this operation but
you could pass any function that would work on an immutable cache, such
as `evict` or `assoc` etc.

Be aware that `memo-swap!` assumes it can wrap each of the `results` values
in a `delay` so that items conform to `clojure.core.memoize`'s world view.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.memoize/blob/2088ed2b2110a7b8deed03f3554f788ad3daae9e/src/main/clojure/clojure/core/memoize.clj#L182">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.memoize/memo-ttl">memo-ttl</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (memo-ttl f)
       (memo-ttl f limit)
       (memo-ttl f limit base)
</pre>
    <pre id="var-docstr">DEPRECATED: Please use clojure.core.memoize/ttl instead.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.memoize/blob/2088ed2b2110a7b8deed03f3554f788ad3daae9e/src/main/clojure/clojure/core/memoize.clj#L443">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.memoize/memoized?">memoized?</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (memoized? f)
</pre>
    <pre id="var-docstr">Returns true if a function has an core.memo-placed cache, false otherwise.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.memoize/blob/2088ed2b2110a7b8deed03f3554f788ad3daae9e/src/main/clojure/clojure/core/memoize.clj#L143">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.memoize/memoizer">memoizer</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (memoizer f cache)
       (memoizer f cache seed)
</pre>
    <pre id="var-docstr">Build a pluggable memoized version of a function. Given a function and a
(pluggable memoized) cache, and an optional seed (hash map of arguments to
return values), return a cached version of that function.

If you want to build your own cached function, perhaps with combined caches
or customized caches, this is the preferred way to do so now.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.memoize/blob/2088ed2b2110a7b8deed03f3554f788ad3daae9e/src/main/clojure/clojure/core/memoize.clj#L247">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.memoize/snapshot">snapshot</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (snapshot memoized-fn)
</pre>
    <pre id="var-docstr">Returns a snapshot of a core.memo-placed memoization cache.  By snapshot
you can infer that what you get is only the cache contents at a
moment in time.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.memoize/blob/2088ed2b2110a7b8deed03f3554f788ad3daae9e/src/main/clojure/clojure/core/memoize.clj#L121">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.memoize/ttl">ttl</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (ttl f)
       (ttl f base)
       (ttl f tkey threshold)
       (ttl f base key threshold)
</pre>
    <pre id="var-docstr">Unlike many of the other core.memo memoization functions,
`memo-ttl`'s cache policy is time-based rather than algorithmic
or explicit.  When memoizing a function using `memo-ttl` you
should provide a **T**ime **T**o **L**ive parameter in
milliseconds.

    (require '[clojure.core.memoize :as memo])

    (def id (memo/ttl identity :ttl/threshold 5000))

    (id 42)
    (snapshot id)
    ;=&gt; {[42] 42}

    ... wait 5 seconds ...
    (id 43)
    (snapshot id)
    ;=&gt; {[43] 43}

The expired cache entries will be removed on each cache **miss**.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.memoize/blob/2088ed2b2110a7b8deed03f3554f788ad3daae9e/src/main/clojure/clojure/core/memoize.clj#L450">Source</a>
  </div>
</div>


</div>
              </div>
            </div>
          </div>
	</div>
	<div id="foot">
	  <div id="copyright" style="text-align: center;">Copyright 2007-2023 by Rich Hickey and the various contributors</div>
	</div>
      </div>
      <div id="DesignedBy">Logo &amp; site design by <a href="http://www.tomhickey.com" title="Visit Tom Hickey's website.">Tom Hickey</a>.<br />
      Clojure auto-documentation system by Tom Faulhaber.</div>
    </div>
    <!-- /AllContentContainer -->
  </body>

</html>